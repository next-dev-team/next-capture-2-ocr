<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Area Selection Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            background: transparent;
            cursor: crosshair;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-app-region: no-drag;
        }

        .selection-area {
            position: absolute;
            border: 2px solid #007AFF;
            background: rgba(0, 122, 255, 0.1);
            display: none;
            pointer-events: none;
        }

        .instructions {
            display: none !important;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #007AFF;
        }

        .instructions p {
            margin: 5px 0;
            opacity: 0.9;
        }

        .instructions .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="instructions" id="instructions">
        <h3>Select Area to Capture</h3>
        <p>Click and drag to select an area</p>
        <p>Press <span class="key">Escape</span> to cancel</p>
    </div>
    
    <div class="selection-area" id="selectionArea"></div>

    <script>
        const { ipcRenderer } = require('electron');
        
        // ===== COORDINATE SYSTEM MANAGER =====
        class CoordinateManager {
            constructor() {
                this.screenStart = { x: 0, y: 0 };
                this.screenEnd = { x: 0, y: 0 };
                this.clientStart = { x: 0, y: 0 };
                this.clientEnd = { x: 0, y: 0 };
            }
            
            setStart(screenX, screenY, clientX, clientY) {
                this.screenStart = { x: screenX, y: screenY };
                this.clientStart = { x: clientX, y: clientY };
                this.screenEnd = { x: screenX, y: screenY };
                this.clientEnd = { x: clientX, y: clientY };
            }
            
            updateEnd(screenX, screenY, clientX, clientY) {
                this.screenEnd = { x: screenX, y: screenY };
                this.clientEnd = { x: clientX, y: clientY };
            }
            
            getScreenBounds() {
                return {
                    x: Math.min(this.screenStart.x, this.screenEnd.x),
                    y: Math.min(this.screenStart.y, this.screenEnd.y),
                    width: Math.abs(this.screenEnd.x - this.screenStart.x),
                    height: Math.abs(this.screenEnd.y - this.screenStart.y)
                };
            }
            
            getClientBounds() {
                return {
                    x: Math.min(this.clientStart.x, this.clientEnd.x),
                    y: Math.min(this.clientStart.y, this.clientEnd.y),
                    width: Math.abs(this.clientEnd.x - this.clientStart.x),
                    height: Math.abs(this.clientEnd.y - this.clientStart.y)
                };
            }
            
            isValidSelection(minSize = 10) {
                const bounds = this.getScreenBounds();
                return bounds.width >= minSize && bounds.height >= minSize;
            }
            
            logCoordinates() {
                console.log('üñ±Ô∏è Coordinate System State:');
                console.log('  Screen Start:', this.screenStart);
                console.log('  Screen End:', this.screenEnd);
                console.log('  Client Start:', this.clientStart);
                console.log('  Client End:', this.clientEnd);
                console.log('  Screen Bounds:', this.getScreenBounds());
                console.log('  Client Bounds:', this.getClientBounds());
            }
        }
        
        // ===== SELECTION MANAGER =====
        class SelectionManager {
            constructor(selectionElement, instructionsElement) {
                this.selectionElement = selectionElement;
                this.instructionsElement = instructionsElement;
                this.isActive = false;
                this.coordinates = new CoordinateManager();
            }
            
            start(screenX, screenY, clientX, clientY) {
                this.isActive = true;
                this.coordinates.setStart(screenX, screenY, clientX, clientY);
                this.instructionsElement.style.display = 'none';
                this.selectionElement.style.display = 'block';
                this.updateVisualSelection();
            }
            
            update(screenX, screenY, clientX, clientY) {
                if (!this.isActive) return;
                this.coordinates.updateEnd(screenX, screenY, clientX, clientY);
                this.updateVisualSelection();
            }
            
            complete() {
                if (!this.isActive) return null;
                
                this.isActive = false;
                this.coordinates.logCoordinates();
                
                if (this.coordinates.isValidSelection()) {
                    const bounds = this.coordinates.getScreenBounds();
                    console.log('üì§ Sending valid selection bounds:', bounds);
                    return bounds;
                } else {
                    console.log('‚ùå Selection too small, resetting');
                    this.reset();
                    return null;
                }
            }
            
            reset() {
                this.isActive = false;
                this.selectionElement.style.display = 'none';
                this.instructionsElement.style.display = 'block';
                this.coordinates = new CoordinateManager();
            }
            
            updateVisualSelection() {
                const bounds = this.coordinates.getClientBounds();
                this.selectionElement.style.left = bounds.x + 'px';
                this.selectionElement.style.top = bounds.y + 'px';
                this.selectionElement.style.width = bounds.width + 'px';
                this.selectionElement.style.height = bounds.height + 'px';
            }
        }
        
        // ===== OVERLAY CONTROLLER =====
        class OverlayController {
            constructor() {
                this.selectionManager = new SelectionManager(
                    document.getElementById('selectionArea'),
                    document.getElementById('instructions')
                );
                this.setupEventListeners();
                console.log('‚úÖ Overlay controller initialized');
            }
            
            setupEventListeners() {
                // Mouse events
                document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                // Window focus
                window.focus();
            }
            
            handleMouseDown(e) {
                this.selectionManager.start(e.screenX, e.screenY, e.clientX, e.clientY);
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                this.selectionManager.update(e.screenX, e.screenY, e.clientX, e.clientY);
                e.preventDefault();
            }
            
            handleMouseUp(e) {
                const bounds = this.selectionManager.complete();
                if (bounds) {
                    this.sendSelectionToMain(bounds);
                    this.closeOverlay();
                }
                e.preventDefault();
            }
            
            handleKeyDown(e) {
                if (e.key === 'Escape') {
                    this.closeOverlay();
                    e.preventDefault();
                }
            }
            
            sendSelectionToMain(bounds) {
                ipcRenderer.send('area-selected', {
                    bounds,
                    timestamp: Date.now()
                });
            }
            
            closeOverlay() {
                window.close();
            }
        }
        
        // ===== INITIALIZATION =====
        const overlayController = new OverlayController();
        console.log('üåê Overlay window loaded and ready');
    </script>
</body>
</html>